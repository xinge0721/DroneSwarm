# 无人机技术路线规划 —— ESP32无人机系统设计

## 核心目标
基于ESP32开发无人机控制系统，重点实现GPS定位、姿态控制和上位机ROS通信，明确各模块职责与数据流，构建可扩展的无人机平台。


## 一、ESP32-S3硬件资源分析与分配

### 硬件资源概况
| 资源类型 | 数量 | 用途分配 |
|----------|------|----------|
| **定时器组** | 4个定时器 | Timer1.0(系统心跳1Hz), Timer0.0/0.1/1.1(备用) |
| **LEDC PWM** | 8通道 | 4通道电机PWM(20kHz) + 4通道备用 |
| **UART** | 3个 | UART0(USB调试), UART1(GPS), UART2(备用扩展) |
| **I2C** | 1个控制器 | IIC0(MPU6050+OLED共用总线) |
| **USB OTG** | 1个 | 原生USB调试接口 |
| **GPIO** | 45个可用 | 4个PWM + 7个I2C/UART/INT + 4个指示 + 1个ADC + 29个备用 |

### 硬件模块配置
| 模块 | 型号规格 | 核心作用 | 接口分配 | 资源使用 |
|------|----------|----------|----------|----------|
| **主控制器** | ESP32-S3-DevKitC-1 | 核心控制器，240MHz双核 | - | 外部中断驱动控制任务 |
| **姿态传感器** | MPU6050（I2C接口） | 姿态数据采集 | IIC0: GPIO8(SDA), GPIO9(SCL), GPIO6(INT) | MPU6050数据就绪中断驱动控制循环(100Hz) |
| **GPS模块** | NEO-M7 | 室外定位 | UART1: GPIO17(RX), GPIO18(TX) | 异步串口接收 |
| **动力系统** | 空心杯电机8520×4 | 四轴升力提供 | LEDC PWM: GPIO1,2,3,4 | LEDC Ch0-3 (20kHz PWM) |
| | 微型电调×4 | 电机驱动 | 连接上述PWM引脚 | - |
| **电池系统** | 3.7V 1000mAh锂电池 | 系统供电 | ADC1(GPIO5电压检测) | 在主控制循环中采样 |
| **显示模块** | 0.96"OLED | 状态显示 | IIC0（共用总线） | 与MPU6050共用IIC0，节省GPIO |
| **指示系统** | 状态LED | 飞行状态指示 | GPIO10(红), GPIO11(绿) | 普通GPIO输出 |
| | 蜂鸣器 | 报警提示 | GPIO12 | 普通GPIO输出(高低电平控制) |
| **调试接口** | USB OTG | 参数调试和数据记录 | 原生USB接口 | Timer1.0(系统心跳1Hz) |
| **扩展接口** | 预留UART2 | 数传/遥控器 | GPIO15(RX), GPIO16(TX) | 需要时启用 |


## 二、系统架构设计

### 主控制循环（100Hz外部中断驱动）
```
MPU6050数据就绪中断 → 控制任务唤醒 (每10ms执行一次):
├── 1. 读取MPU6050数据 (I2C, ~1ms) [保证新数据]
├── 2. 卡尔曼滤波处理姿态数据 (~0.5ms)  
├── 3. PID控制计算 (期望姿态 vs 当前姿态, ~0.5ms)
├── 4. 更新电机PWM输出 (~0.2ms)
├── 5. 电池电压采样 (每10次执行1次, ~0.1ms)
├── 6. OLED显示更新 (每10次执行1次, ~1ms)
└── 7. WiFi数据发送 (每2次执行1次, 50Hz数据流)
总耗时: ~3-4ms，节省1个定时器资源，数据同步更精确
```

### 通信接口配置

#### 标准配置（MPU6050 + NEO-6M）
| 接口类型 | 用途 | 连接设备 | 配置参数 | 处理方式 |
|----------|------|----------|----------|----------|
| USB OTG | 参数调试 | 电脑USB口 | 115200 | 原生USB，实时修改PID参数 |
| UART1 | GPS数据 | NEO-6M | 9600 | 串口中断接收，主循环解析 |
| I2C0 | 姿态传感器 | MPU6050 | 400kHz | 定时器中断中读取 |
| I2C1 | 显示屏 | OLED | 400kHz | 定时器中断中更新(10Hz) |
| UART2 | 扩展接口 | 数传/遥控器 | 可配置 | 需要时启用 |

#### 初号机配置（JY60 + NEO-M8N）  
| 接口类型 | 用途 | 连接设备 | 配置参数 | 处理方式 |
|----------|------|----------|----------|----------|
| USB OTG | 参数调试 | 电脑USB口 | 115200 | 原生USB调试 |
| UART1 | GPS数据 | NEO-M8N | 9600 | 串口中断接收 |
| UART2 | 姿态传感器 | JY60 | 9600 | 串口中断接收 |
| I2C1 | 显示屏 | OLED | 400kHz | 定时器中断更新 |

### 资源优化设计要点

#### 1. 定时器资源节约
- **合并控制循环**：PID控制、卡尔曼滤波、状态更新合并到单个100Hz定时器中断
- **时间片管理**：在10ms时间片内，按优先级顺序执行各任务，总耗时控制在4ms内
- **分频处理**：电池电压和OLED更新采用分频方式，降低处理频率

#### 2. PWM资源节约  
- **电机专用**：4个LEDC PWM通道专门用于电机控制(20kHz)
- **蜂鸣器简化**：报警蜂鸣器使用普通GPIO高低电平控制，无需占用PWM资源

#### 3. I2C总线分离
- **避免冲突**：MPU6050和OLED分别使用不同I2C控制器，避免地址冲突和时序问题
- **并行处理**：两个I2C总线可以并行工作，提高系统响应速度

#### 4. DMA资源配置建议
- **UART1（GPS）DMA**：NEO-M7数据接收使用DMA，减少CPU中断负担
- **ADC DMA**：电池电压采样可配置DMA连续采样，提高精度
- **UDP发送DMA**：WiFi数据发送考虑使用DMA，减少主循环阻塞
- **IIC DMA**：MPU6050高频数据读取可配置DMA，提升100Hz控制循环效率

**DMA通道分配建议**：
- DMA Channel 0: UART1 RX (GPS数据)  
- DMA Channel 1: ADC (电池电压采样)
- DMA Channel 2: WiFi TX (UDP数据发送)
- DMA Channel 3: IIC RX (MPU6050数据读取)
- **原生USB**：使用ESP32-S3原生USB接口进行调试，无需占用UART资源
- **实时参数调整**：通过USB接口实时修改PID参数，便于调试和优化


## 三、三层核心逻辑（无人机端→通信→上位机ROS）
### 1. 无人机端（ESP32固件，C/Arduino实现）
#### 核心功能：
- **多串口数据处理**：
  - UART0（PID调试）：接收电脑发来的PID参数指令（如"P1=2.5,P2=0.3"），实时更新PID系数；
  - UART1（GPS）：解析NEO-M7的NMEA协议（取`$GNRMC`语句），提取经纬度、卫星数；
  - UART2（备用）：预留扩展接口（原JY60改为MPU6050 IIC接口）。
- **边缘计算优化**：
  - **PID控制**：姿态PID控制在ESP32本地完成，确保实时性
  - **坐标转换**：GPS经纬度→UTM坐标转换在ESP32完成，减少通信负载
- **数据打包发送**：将"姿态+UTM坐标+电池电压+PID参数"整合成JSON，通过WiFi-UDP发往上位机（50Hz频率），示例：
  ```json
  {
    "drone_id": "test_01",
    "roll": 1.1, "pitch": 0.8, "yaw": 359.2,  // JY60数据
    "utm_x": 1234.56, "utm_y": 5678.90,      // 已转换UTM坐标
    "sat": 13, "batt": 3.85,                  // 卫星数、电池电压
    "pid_p": 2.5, "pid_i": 0.3, "pid_d": 0.8  // 当前PID参数
  }
  ```
- **控制指令执行**：接收上位机的"期望姿态指令"（roll/pitch/throttle），通过PID计算输出4路PWM，驱动电机。


### 2. 通信层（WiFi-UDP）
- 无人机端：ESP32连接电脑热点（如“drone_test”），固定IP（192.168.1.101）；
- 上位机端：笔记本通过同一热点，与ESP32建立UDP连接，确保数据延迟<100ms（满足控制需求）。


### 3. 上位机ROS功能包（仅笔记本运行，7个包协同工作）

#### 🚁 **无人机核心功能包**（4个包）
| ROS功能包          | 核心作用                          | 关键话题/指令                          |
|---------------------|-----------------------------------|----------------------------------------|
| **udp_ros_bridge**  | 通信桥梁：UDP↔ROS话题转换         | 接收：无人机JSON数据→发布`/test_01/imu`（姿态）、`/test_01/gps`（GPS）；<br>发送：订阅`/test_01/cmd_vel`（控制指令）→ 转UDP给ESP32 |
| **swarm_data_processor** | 数据统合：多机状态监控+数据记录    | 1. 多机状态汇总（发布`/swarm_status`，便于集群监控）；<br>2. 低电量（<3.5V）、GPS弱信号（<6颗星）→ 发布`/drone_alarm`报警 |
| **swarm_planner**   | 路径规划：语音指挥+轨迹生成      | 1. 订阅`/cmd/voice`语音指令→生成路径（发布`/test_01/path`）；<br>2. 简单路径规划算法（A*基础版本） |
| **gazebo_simulator** | 仿真验证：算法测试+安全预演      | 1. 仿真多机协同算法验证；<br>2. 路径规划算法测试；<br>3. 危险场景安全测试 |


#### 🎤 **智能语音AI功能包**（3个包，已完整实现）
| ROS功能包          | 核心作用                          | 关键话题/指令                          | 实现状态 |
|---------------------|-----------------------------------|----------------------------------------|----------|
| **language**        | 语音识别：中文语音→文字转换       | 订阅`/mic/awake/angle`（麦克风唤醒）→ 发布`chatter`（识别结果） | ✅ 完整实现 |
| **xinhuo**          | AI对话：智能指令理解和决策        | 订阅`chatter`（语音文字）→ 调用星火API → 发布`/tts/text`（AI回答） | ✅ 完整实现 |
| **mic**             | 语音合成：文字→语音播报           | 订阅`/tts/text`（文字内容）→ TTS合成 → 扬声器输出 | ✅ 完整实现 |

#### 🔧 **语音AI系统技术详解**

**🎤 语音识别模块（language包）技术栈：**
- **Vosk离线引擎**：支持中文识别，无需网络连接
- **自适应VAD算法**：环境噪音自动校准，动态调整静默阈值
- **麦克风阵列支持**：USB Audio设备自动识别，支持多通道
- **ROS集成**：标志位同步设计，避免并发访问崩溃问题
- **性能优化**：预热模型加载，响应速度<200ms

**🤖 AI对话模块（xinhuo包）技术栈：**
- **星火大模型4.0Ultra**：讯飞最新版本，理解能力强
- **WebSocket实时连接**：低延迟对话，支持流式返回
- **智能历史管理**：8000字符上下文，自动清理超长对话
- **指令解析能力**：
  ```
  "飞到那边" → AI结合视觉/GPS解析目标坐标
  "所有无人机返航" → 识别为集群控制指令
  "电池怎么样" → 识别为状态查询指令
  "立即悬停" → 识别为紧急安全指令
  ```

**🔊 语音合成模块（mic包）技术栈：**
- **讯飞TTS引擎**：多角色语音（李白、小燕等人格化角色）
- **实时状态播报**：电池电量、GPS信号、飞行状态
- **异常告警语音**：低电量、信号丢失、设备故障提醒
- **指令确认反馈**："收到指令，开始执行飞行任务"


## 四、验证步骤（从单模块到智能系统联调）

### 🔧 **Step 0：语音AI环境一键配置**（必需的前置步骤）
**重要：在进行任何语音AI相关测试前，必须先运行环境配置脚本**

```bash
cd Software/Hive_control_ROS/环境
sudo chmod +x robot.sh
sudo ./robot.sh
```

**该脚本自动完成的关键配置：**
1. **系统依赖安装**：
   - 音频库：`libasound2-dev`, `sox`, `portaudio19-dev`
   - 开发工具：`vim`, `terminator`, `cmake`, `git`
   - Python包：`websocket-client`, `vosk`, `sounddevice`

2. **Vosk语音模型管理**：
   - 自动下载：`vosk-model-cn-kaldi-multicn-0.15`（约200MB）
   - 智能解压：处理嵌套目录，修复解压问题
   - 模型验证：测试加载和识别功能

3. **设备权限配置**：
   - CH9102串口设备权限（`ch9102_udev.sh`）
   - 音频设备访问权限
   - 动态链接库配置

4. **库文件安装**：
   - 根据系统架构自动选择（x64/arm64/x86）
   - cJSON库编译安装
   - 讯飞TTS引擎依赖

5. **功能测试验证**：
   - 自动创建`test_vosk.py`测试脚本
   - 验证语音识别模型完整性
   - 测试音频处理流程

**配置完成后建议重启系统，然后继续后续步骤。**

###  Step 1：硬件单独测试（确保每个模块能用）
1. **串口测试**：用电脑USB接ESP32的UART0（PID调试口），通过串口助手发送指令，确认ESP32能接收并回复（验证调试串口正常）；
2. **GPS测试**：室外放置M8N，用串口助手读UART1数据，确认卫星数≥6，经纬度稳定（误差<2米）；
3. **姿态测试**：接JY60到UART2，晃动无人机，确认姿态数据连续变化（无跳变）；
4. **电机测试**：给电调供电，通过ESP32输出PWM，确认4个电机转速可调（0-100%），对角转向相反。

###  Step 2：固件调试（无人机端核心逻辑）
1. 先实现“单模块+OLED显示”：比如JY60姿态在OLED实时刷新，GPS卫星数显示；
2. 加入WiFi通信：确保上位机能收到完整JSON数据（用网络调试助手验证）；
3. 调试PID串口：通过UART0发送“PID_P=2.5”，确认OLED能显示新参数（实时生效）。

###  Step 3：ROS联调（上位机控制逻辑）
1. 启动`udp_ros_bridge`：在RViz中添加`/test_01/gps`话题，看到红色圆点跟随无人机移动；
2. 启动`drone_planner`：输入目标UTM坐标（比如当前坐标+3米），看到`/test_01/path`显示直线路径；
3. 地面测试：无人机放在地面，发送控制指令，确认电机能根据GPS偏差调整转速（比如偏向目标方向时，对应电机加速）。

###  Step 4：试飞验证（低空小范围测试）
1. 室外无遮挡环境，低空悬停（1米高），观察姿态是否稳定（PID参数不合适则微调UART0的参数）；
2. 简单路径跟踪：控制无人机从A点飞到3米外B点，确认能大致按规划路径飞行，GPS定位准确。


## 五、后续优化方向
1. **硬件优化**：系统验证稳定后，可考虑使用MPU6050替代JY60，NEO-6M替代NEO-M8N，进一步降低系统成本；
2. **多机扩展**：新增无人机时，只需修改`drone_id`和IP，ROS功能包无需重构（复用`udp_ros_bridge`和`drone_planner`）；
3. **功能升级**：UART3可接光流模块（室内定位），解决GPS室内失效问题。


## 核心总结

### 🚀 **系统架构升级**
整个方案基于ESP32构建智能无人机控制系统，通过复用成熟的语音AI代码框架，实现了四层智能架构：
1. **ESP32固件层**："数据采集+姿态控制"，硬件接口精确分配
2. **ROS核心层**："数据处理+路径规划"，传统无人机功能
3. **语音AI层**："语音识别+智能决策+TTS反馈"，自然交互
4. **用户交互层**：语音指挥取代复杂操控，降低使用门槛

### 🎤 **智能化核心优势**
- **自然语言控制**："飞到那边"比手动设置GPS坐标更直观
- **AI辅助决策**：星火大模型理解复杂指令，减少操作错误
- **实时状态反馈**：语音播报取代屏幕查看，解放双眼
- **紧急安全控制**："立即停止"等语音指令响应更快
- **多机协同简化**："所有无人机返航"一句话控制整个集群

### 🔄 **数据流闭环**
```
用户语音指令 → 语音识别 → AI理解 → 路径规划 → 无人机执行 → 状态上报 → 语音播报 → 用户确认
```

整个系统从传统的"手动操控"升级为"智能对话"模式，用户可通过自然语言与无人机集群进行交互，大幅降低操作复杂度，提升使用体验。按步骤逐步验证各模块功能，确保系统稳定可靠，最终实现真正的"对话式"无人机控制体验。